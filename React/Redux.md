# Redux

## Why Redux

_Vanilla JS_ is suitable for ultra simple app that does not need any DOM manipulation. You can add _jQuery_ into the application if you need reusable code for DOM manipulation and other simplified HTTP requests etc, the disadvantage is maintaining the code is complicated over the time. _React_ is great for bigger projects because of _clear component model, synthetic events, and virtual dom_. React becomes complex when same data need to display in multiple places. _Redux_ makes data management very easy.

## Foundation of Redux

### 1. One Immutable store for entire application

Helps debugging, helps server rendering, do undo / redo etc.

### 2. Actions are always trigger changes

Action describes user's intent, example a click event for new customer.

### 3. State is changed by pure function (reducers)wz

## Redux flow

There is one main __store__ for the entire application, the _store_ holds state of all components. _State_ of the _store_ can only be modified by __reducers__, _store_ can have only __one root reducer__, the _root reducer_ is created by combining many _reducers_. The reducers use an __action__ to identify the _action_ that required to perform, an _action_ contains __type__ and __payload__. The __containers__ are the `.jsx` files that contains logic behind _components_, the _containers_ __dispatch__ an _action_ to perform an operation. When an _action_ is _dispatched_, all the _reducers are notified_. The _reducers_ use a `switch` operator on _action.payload_ to identify if the action is intended for it. The __react components__ include the __Containers__ in it.

![](redux-flow.png)

## Key components

### Actions

The events happening in the application are called _Actions_. Actions are just plain _js_ object containing description on the event. An action must have a _type_ and a _property_.

```js
rateCourse(rating){
    return { type: RATE_COURSE, rating: rating }
}
```

### Store

You can create a store by calling `createStore()` in your application's entry point. The redux store is the single source of truth. Having a single source of truth makes the application easier to manage. Following are the `API` for _redux store_.

1. `store.dispatch(action)`
2. `store.subscribe(listener)`
3. `store.getState()`
4. `replaceReducer(nextReducer)`

```js
let store = createStore(rootReducer);
```

### Reducers

To change the state of store, you dispatch an _action_ that ultimately handled by a _reducer_. Reducer is a simple _javascript_ function that take the _state_ and _action_ and return the new _state_. All reducers are called when an action is dispatched. Each reducer look at the _action.type_ and decide if it need to act on the request.

```js
function myReducer(state, action){
    switch(action.type){
        case 'INCREMENT_COUNTER':
            return(
                {}, // Empty object
                state, // Existing state
                {counter: state.counter + 1} // set the new value for counter variable
            ); // Deep clone of all the above
        default:
            return state;
    }
}
```

### Containers vs components

Container | Components / Presentational
----------|-----------------------------
Focus on how things work | Focus on how things look
Aware of redux | Unaware of redux
Subscribe to Redux State | read from props
Dispatch Redux actions | Invoke callbacks on props
Generated by react-redux | written by hand

#### Methods to copy data in javascript

##### ES6 Object.Assign

The first parameter should be always an empty object.

```js
Object.assign(target, ...sources)

// Example
Object.assign({}, state, {role: 'admin'});
```

#### Spread operator

## Libraries

### React-redux

Helps to connect `React` with `Store`. The redux library can be used with other frameworks as well (e.g. Angular). React redux has two main components.

#### Provider

Attaches app to store

#### Connect

Creates container components