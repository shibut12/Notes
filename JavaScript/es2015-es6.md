# ES 2015 - ES 6

New way to improve javascript code.

## Right parts

### => Arrow function

Is the new way of declaring function. They are syntactically anonymous.

```js
// ES6
foo => 2;
// Pre ES6
function foo() {
    return 2;
}
```

If there is not curley brace `{}` around the right side of arrow function, it implies a return. For Example, `foo => 2;` mean, function foo returns value 2. 
If the body of the arrow function is expression, it has to be wrapped in a curley braces `{}`. In this case, there will not be an _implicit return_.

```js
// Example
x => { try { return 3; } catch(e) {} }
```

To return a json object, the json object should be wrapped in parenthesis.

```js
//Example
x=> ({ y: x })
```

#### Name inferrencing

A way to assign a name to anonymous arrow function.

```js
var foo = x => 3;
foo.name = foo;
```

#### Arrow functions vs named function or down sides to using anonymous functions

* Named function are better when you have to self reference to itself, for example in recursion
* Anonymous functions show up as anonymous in stacktrace

## Promises and This

`this` always refer to the context of the current object.

Example in the following code block would display `undefined Sue and undefined Joe.`. This is because the `this` in `forEach` refer to the context of `forEach`

```js
let message = {
  hello : 'Hello',
  names : ['Sue', 'Joe'],
  showMessage: function() {
    this.names.forEach(name => {
      console.log(this.hello + ' ' + name);
    });
  }
}
message.showMessage()
```

One way to fix this is, assign `this` to a variable and use it in the function.

```js
let message = {
  hello : 'Hello',
  names : ['Sue', 'Joe'],
  showMessage: function() {
    let self = this;
    this.names.forEach(function(name) {
      console.log(self.hello + ' ' + name);
    });
  }
}
message.showMessage(); 
```

Output

```js
Hello Sue and Hello Joe.
```

## Spread operator `{...}`

The _spread_ operator allows to have large parameter list but have as cleaner code.

```js
// Before ES6
function func1(param1, param2, param3, param4){
    console.log(param1);
    console.log(param2);
    console.log(param3);
    console.log(param4);
}

// After ES6
function func1({...props}){
    console.log(props.param1);
    console.log(props.param2);
    console.log(props.param3);
    console.log(props.param4);
}
```

## Default function parameters

ES6 allows to set default values using `=` operator.

```js
function showMessage(who, {p1 = "Hello", p2="World"} = {}) {
  console.log(who + ' says ' + p1 + ' ' + p2);
}
showMessage("Shibu");

// output
Shibu says Hello World
```
## Classes

`Class` in javascript is not same as `Class` in object oriented languages like C#. It is a feature that built around _Prototypical Inheritance_.

Example.
```js
class Animal {
  constructor(name) {
    this.name = name;
  }
    
  printName() {
    console.log(this.name);
  }
} 
```

the above code in _Prototypical inheritance_ would be as below.

```js
function Animal(name) {
  this.name = name;
}
      
Animal.prototype.printName = function() {
  console.log(this.name);
}
```

### Constructor
Runs automatically always when a new _object_ is created. If one is not included JavaScript will automatically created for you.

### Static methods
Static methods a re not part of any instance of the class, meaning that you can refer to these methods without referring to an instance.

```js
static methodName() {
  return 'something';
}
```

### Prototype methods
These methods do not include the `static` keyword and must be referenced with an instance

### Getters and setters

The accessor functions work just like object literals and work the same as they did in ES5. Essentially you put `get` and `set` keywords in front of the property name. If you define a  _getter_ property without a _setter_ property, it becomes __readonly__.

```js
get area() {
  return this.height * this.width;
 }

set area(value) {
  this.area = value;
} 
```

### Inheritance

Classes comes in 2 flavors:

* base class
* derived class

The difference eis `extends` keyword. Derived classes have them and base classes dont have them.

Example

```js
// Base class

class Parent {
    constructor(name) {
        this.name =name;
    }

    getName() {
        return this.name;
    }
}

// Derived class
class Child extends Parent {
    constructor(name){
        super(name);
    }

    getMessage() {
        return 'Hello ' + super.getName();
    }
}

let someOne = new Child('person');
console.log(someOne.getMessage());

// Output
Hello person
```


